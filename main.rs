// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#![crate_type = "bin"]
#![crate_name = "lrs_build"]
#![feature(std_misc, fs_time, os, libc)]
#![allow(deprecated)]

extern crate libc;

use std::path::{AsPath};
use std::{env, mem, os, thread, cmp};
use std::io::{self, BufReader, BufRead, Write};
use std::rc::{Rc};
use std::cell::{RefCell};
use std::fs::{self, File};
use std::process::{Command};
use std::sync::mpsc::{channel, Receiver, Sender};

/// Print an error to stderr and exit.
macro_rules! err {
    ($fmt:expr) => { err!(concat!($fmt, "{}"), "") };
    ($fmt:expr, $($arg:tt)*) => {{
        let mut stderr = io::stderr();
        let _ = writeln!(&mut stderr, $fmt, $($arg)*);
        unsafe { libc::_exit(1); }
    }};
}

/// Object containing the state of the build process.
#[derive(Debug)]
struct Build {
    start: Option<String>,
    objs: Vec<Rc<RefCell<Obj>>>,
}

/// Status of an obj that needs rebuilding.
#[derive(Debug, PartialEq)]
enum BuildStatus {
    /// Build has not yet started
    Pending,
    /// Building right now
    Building,
    /// Done building
    Built,
}

/// A single object in our build tree.
#[derive(Debug)]
struct Obj {
    /// Name of the object, e.g., "core" or "file".
    name: String,
    /// Whether the object need rebuilding.
    needs_rebuild: Option<bool>,
    /// If needs_rebuild is false, then this contains the date the object was built.
    obj_modified: Option<u64>,
    /// If needs_rebuild is true, then this contains the status of the built.
    build_status: BuildStatus,
    /// The dependencies of this object.
    deps: Vec<Rc<RefCell<Obj>>>,
}

impl Obj {
    /// Creates a new, empty object from the given name.
    fn from_name(n: String) -> Obj {
        Obj {
            name: n,
            needs_rebuild: None,
            obj_modified: None,
            build_status: BuildStatus::Pending,
            deps: vec!(),
        }
    }

    /// Checks whether this object has to be rebuilt. Returns the result.
    ///
    /// After this function returns, the needs_rebuild field is `Some` for this object
    /// and, recursively, all of its dependencies.
    fn check_needs_rebuild(&mut self) -> bool {
        // The check was already run for this object. This can happen if this is a
        // dependency of multiple objects.
        if self.needs_rebuild.is_some() {
            return self.needs_rebuild.unwrap();
        }

        // Store the last time any of the objects dependencies was built.
        let mut last_dep_built = 0;
        for dep in &self.deps {
            let mut dep = dep.borrow_mut();
            if dep.check_needs_rebuild() {
                // If a dependency has to be rebuilt, then this object also has to be
                // rebuilt. We don't return here because of the guarantee in the function
                // documentation.
                self.needs_rebuild = Some(true);
            } else {
                // If we don't have to rebuilt this dependency, then we might still have
                // to rebuild this object because the dependency was built after this
                // object was built.
                last_dep_built = cmp::max(last_dep_built, dep.obj_modified.unwrap());
            }
        }

        if self.needs_rebuild == Some(true) {
            return true;
        }

        // Generate the full name of the object. If the name is "linux", then it refers to
        // the final crate "linux" which is already its full name. Otherwise, e.g. if it's
        // "core" or "file", the full name has the "linux_" prefix.
        let full_name = match &self.name[..] {
            "linux" => "linux".to_string(),
            _ => format!("linux_{}", self.name),
        };
        let obj_path = format!("obj/lib{}.rlib", full_name);

        // Check when the compiled object was last modified.
        let obj_modified = match fs::metadata(&obj_path) {
            Ok(m) => m.modified(),
            _ => {
                // If the object doesn't exist then we definitely have to rebuilt.
                self.needs_rebuild = Some(true);
                return true;
            },
        };

        // The object exists. We have to check if any of the dependencies were rebuilt
        // after this object was build.
        if obj_modified < last_dep_built {
            self.needs_rebuild = Some(true);
            return true;
        }

        // Load the ".d" file generated by rustc which contains the files that were used
        // to compile this object, e.g, "lib.rs".
        let mut dep_path = "obj".as_path().to_path_buf();
        dep_path.push(&format!("{}.d", full_name));
        let deps_file = match File::open(&dep_path) {
            Ok(f) => BufReader::new(f),
            _ => {
                // For some reason the ".rlib" exists but the ".d" doesn't exist. In this
                // case we just rebuild the object.
                self.needs_rebuild = Some(true);
                return true;
            },
        };
        // The line that starts with "obj/libfull_name.rlib: " contains our dependencies.
        let mut files: Option<Vec<String>> = None;
        for line in deps_file.lines() {
            let line = line.unwrap();
            if line.starts_with(&obj_path) {
                let line = &line[obj_path.len()+2..];
                files = Some(line.split(' ').map(|w| w.to_string()).collect());
                break;
            }
        }
        let files = match files {
            Some(f) => f,
            _ => {
                // For some reason the file didn't contain the correct line. We just
                // rebuild.
                self.needs_rebuild = Some(true);
                return true;
            },
        };

        // Check the modification time of all the files that were used to build this
        // object.
        for file in files {
            match fs::metadata(&file) {
                Ok(ref m) if m.modified() <= obj_modified => { },
                _ => {
                    self.needs_rebuild = Some(true);
                    return true;
                },
            }
        }

        // If we don't rebuild this object, then we have to store the last time it was
        // built in obj_modified.
        self.needs_rebuild = Some(false);
        self.obj_modified = Some(obj_modified);
        false
    }
}

/// Gets the next sub-target of this object that can be built, or `Err(false)` if there
/// are no more subtargets to be built, or `Err(true)` if there are more subtargets to be
/// built but they cannot be built right now.
fn next_target(obj: &Rc<RefCell<Obj>>) -> Result<Rc<RefCell<Obj>>, bool> {
    let mut can_build = true;

    {
        let obj = obj.borrow();

        // If this object doesn't need rebuilding, then none of the dependencies need
        // rebuilding either. If this object has already been built, then all dependencies
        // have already been built.
        if !obj.needs_rebuild.unwrap() || obj.build_status == BuildStatus::Built {
            return Err(false);
        }

        // If this object is being built right now, then all dependencies have been built
        // and there is nothing else to do. We return `true` because objects that depend
        // on this object can't be built yet.
        if obj.build_status == BuildStatus::Building {
            return Err(true);
        }

        // We check all dependencies. If there is a dependency that can be built, then we
        // built it. If there are dependencies that have not been built yet and cannot be
        // built right now, then we cannot built this object either.
        for dep in &obj.deps {
            match next_target(dep) {
                Ok(t) => return Ok(t),
                Err(true) => can_build = false,
                _ => { },
            }
        }
    }

    match can_build {
        true => Ok(obj.clone()),
        _ => Err(true),
    }
}

/// Find the LRSBuild directory and the second directory after it.
///
/// The directory layout is `conf_dir/src/file` so the second directory after it can be,
/// e.g., "file" or "core".
fn find_conf() -> (String, Option<String>) {
    let mut cwd = env::current_dir().unwrap();
    let mut last = None;
    let mut second_to_last = None;
    loop {
        cwd.push("LRSBuild");
        let exists = fs::metadata(&cwd).is_ok();
        cwd.pop();
        if exists {
            return (cwd.to_str().unwrap().to_string(), second_to_last);
        }
        mem::swap(&mut last, &mut second_to_last);
        last = cwd.file_name().map(|f| f.to_str().unwrap().to_string());
        if last.is_none() {
            err!("Cannot find LRSBuild");
        }
        cwd.pop();
    }
}

/// Parse the contents of LRSBuild
fn parse(build: &mut Build) {
    let mut preobjs: Vec<(String, Vec<String>)> = vec!();

    for line in BufReader::new(fs::File::open("LRSBuild").unwrap()).lines() {
        let line = line.unwrap();
        let words: Vec<&str> = line.trim().split(' ').map(|w| w.trim())
                                   .filter(|w| w.len() > 0).collect();
        if words.len() > 0 {
            match words[0] {
                "obj" => {
                    assert!(words.len() > 1);
                    preobjs.push((words[1].to_string(),
                                  words[2..].iter().map(|w| w.to_string()).collect()));
                },
                _ => err!("expected predicate"),
            }
        }
    }

    for preobj in preobjs {
        let mut obj = Obj::from_name(format!("{}", preobj.0));
        for dep in preobj.1 {
            let dep_name = format!("{}", dep);
            match build.objs.iter().find(|x| x.borrow().name == dep_name) {
                Some(x) => obj.deps.push(x.clone()),
                _ => err!("can't find dependency {} of {}", dep_name, obj.name),
            }
        }
        build.objs.push(Rc::new(RefCell::new(obj)));
    }
}

/// Gets the object we're interested in building.
///
/// This is either the "linux" object or the object in whose directory tree we are right
/// now, e.g., if we are in `src/file` or any subdirectory, then we only want to build
/// `file` and its dependencies.
fn get_base_obj(build: &Build) -> Rc<RefCell<Obj>> {
    let obj = build.start.as_ref().and_then(|s| build.objs.iter()
                         .find(|o| &o.borrow().name == s));
    match obj {
        Some(o) => o.clone(),
        _ => {
            let mut obj = Obj::from_name("linux".to_string());
            obj.deps = build.objs.clone();
            Rc::new(RefCell::new(obj))
        },
    }
}

/// The function that calls `rustc` and waits for it to exit.
fn build_thread(num: usize, req_recv: Receiver<String>, res_send: Sender<(usize, bool)>) {
    for req in req_recv.iter() {
        let mut cmd = Command::new("rustc");
        cmd.arg("--emit=link,dep-info");
        cmd.arg("--out-dir=obj");
        cmd.arg("-L").arg("obj");
        cmd.arg(&format!("src/{}/lib.rs", req));
        let res = cmd.spawn().and_then(|mut p| p.wait()).map(|r| r.success())
                     .unwrap_or(false);
        res_send.send((num, res)).unwrap();
    }
}

fn main() {
    // For easier debugging of crashes.
    env::set_var("RUST_BACKTRACE", "true");

    let (top_dir, start) = find_conf();
    env::set_current_dir(&top_dir).unwrap();
    let mut build = Build { start: start, objs: vec!() };
    parse(&mut build);
    let target = get_base_obj(&build);
    target.borrow_mut().check_needs_rebuild();

    let _ = fs::create_dir("obj");

    let (res_send, res_recv) = channel();
    let mut threads = vec!();
    for i in 0..os::num_cpus() {
        let (req_send, req_recv) = channel();
        let res_send = res_send.clone();
        thread::spawn(move || build_thread(i, req_recv, res_send));
        threads.push((req_send, None));
    }
    let mut num_building = 0;

    let mut cur_target = None;
    'outer: loop {
        if cur_target.is_none() {
            // Find the next target that can be built. If nothing new can be built and
            // there are not compilations running, then we're done.
            cur_target = match next_target(&target) {
                Ok(t) => Some(t),
                Err(false) if num_building == 0 => break,
                _ => None,
            };
        }

        if cur_target.is_some() && num_building < threads.len() {
            for thread in &mut threads {
                if thread.1.is_none() {
                    let cur_target = cur_target.take().unwrap();
                    {
                        let mut target = cur_target.borrow_mut();
                        target.build_status = BuildStatus::Building;
                        println!("  building {}", target.name);
                    }
                    thread.0.send(cur_target.borrow().name.clone()).unwrap();
                    thread.1 = Some(cur_target);
                    num_building += 1;
                    continue 'outer;
                }
            }
        }

        // Either there is currently no target or all threads are busy.

        let (thread_num, res) = res_recv.recv().unwrap();
        let target = threads[thread_num].1.take().unwrap();
        if !res {
            err!("building {} failed", target.borrow().name);
        }
        num_building -= 1;
        target.borrow_mut().build_status = BuildStatus::Built;
    }
}
